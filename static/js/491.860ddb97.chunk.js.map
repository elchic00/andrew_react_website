{"version":3,"file":"static/js/491.860ddb97.chunk.js","mappings":"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","sources":["components/Snake.jsx"],"sourcesContent":["import { useEffect, useRef, useState } from \"react\";\n\n/**\n * Local Snake component (replacement for react-simple-snake)\n * Props:\n * - percentageWidth: number|string (percent of parent width, e.g. 50 or \"50\")\n * - startSnakeSize: number (initial snake length)\n * - appleColor: string\n * - snakeColor: string\n * - gridSize: number (number of cells per side)\n * - speed: number (ms per step)\n */\nconst PlaySnake = ({\n  percentageWidth = 50,\n  startSnakeSize = 4,\n  appleColor = \"red\",\n  snakeColor = \"green\",\n  gridSize = 20,\n  speed = 67,\n}) => {\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const runningRef = useRef(true);\n  const gameOverRef = useRef(false);\n  const [running, setRunning] = useState(true);\n  const [score, setScore] = useState(0);\n  const [highScore, setHighScore] = useState(() => parseInt(localStorage.getItem(\"snakeHighScore\") || \"0\", 10));\n  const [newHighScore, setNewHighScore] = useState(false);\n  const [gameOver, setGameOver] = useState(false);\n  const [tick, setTick] = useState(0); // used to trigger restart\n\n  useEffect(() => {\n    localStorage.setItem(\"snakeHighScore\", String(highScore));\n  }, [highScore]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext(\"2d\");\n\n    let size = gridSize;\n    // compute canvas pixel size based on container width and percentageWidth\n    const computeSize = () => {\n      const containerWidth = containerRef.current ? containerRef.current.clientWidth : 600;\n      const pct = typeof percentageWidth === \"string\" ? parseFloat(percentageWidth) : percentageWidth;\n      const canvasPx = Math.max(200, Math.floor((containerWidth * pct) / 100));\n      // make square canvas and ensure scale is integer\n      const scale = Math.floor(canvasPx / size) || 10;\n      canvas.width = scale * size;\n      canvas.height = scale * size;\n      return { scale, size };\n    };\n\n    let { scale } = computeSize();\n      // disable smoothing for pixel-perfect output\n      if (ctx.imageSmoothingEnabled !== undefined) ctx.imageSmoothingEnabled = false;\n\n    // game state\n  let snake = [];\n  let dir = { x: 1, y: 0 };\n  let lastDir = { x: 1, y: 0 };\n  let apple = { x: 0, y: 0 };\n  let currentScore = 0;\n  // mutable step interval (ms per step) - will decrease when eating apples to speed up\n  let stepInterval = Math.max(25, speed || 50);\n\n    const resetState = () => {\n      snake = [];\n      const startX = Math.floor(size / 2);\n      const startY = Math.floor(size / 2);\n      for (let i = 0; i < startSnakeSize; i++) {\n        snake.push({ x: startX - i, y: startY });\n      }\n      dir = { x: 1, y: 0 };\n      lastDir = { x: 1, y: 0 };\n      currentScore = 0;\n      runningRef.current = true;\n      stepInterval = Math.max(25, speed || 50);\n      setNewHighScore(false);\n      placeApple();\n      setGameOver(false);\n      gameOverRef.current = false;\n      setScore(0);\n    };\n\n    const placeApple = () => {\n      let spot = null;\n      // pick a random cell that's not on the snake; avoid declaring functions inside the loop\n      while (true) {\n        const x = Math.floor(Math.random() * size);\n        const y = Math.floor(Math.random() * size);\n        let collision = false;\n        for (let i = 0; i < snake.length; i++) {\n          if (snake[i].x === x && snake[i].y === y) {\n            collision = true;\n            break;\n          }\n        }\n        if (!collision) {\n          spot = { x, y };\n          break;\n        }\n      }\n      apple = spot;\n    };\n\n    const draw = () => {\n      // background\n      ctx.fillStyle = \"#0f172a\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // apple\n      ctx.fillStyle = appleColor;\n      ctx.fillRect(apple.x * scale, apple.y * scale, scale, scale);\n\n      // snake\n      ctx.fillStyle = snakeColor;\n      snake.forEach((s, i) => {\n        ctx.fillRect(s.x * scale, s.y * scale, scale - 1, scale - 1);\n      });\n    };\n\n    const step = () => {\n      if (!runningRef.current) return;\n\n      const head = { x: (snake[0].x + dir.x + size) % size, y: (snake[0].y + dir.y + size) % size };\n\n      // self collision\n      if (snake.some((s) => s.x === head.x && s.y === head.y)) {\n        runningRef.current = false;\n        setRunning(false);\n        setGameOver(true);\n        gameOverRef.current = true;\n        setHighScore((h) => Math.max(h, currentScore));\n        return;\n      }\n\n      snake.unshift(head);\n\n      // eat apple\n      if (head.x === apple.x && head.y === apple.y) {\n        currentScore += 1;\n        setScore(currentScore);\n        // check and update high score\n        if (currentScore > highScore) {\n          setHighScore(currentScore);\n          setNewHighScore(true);\n          localStorage.setItem(\"snakeHighScore\", String(currentScore));\n        }\n        // speed up: decrease interval down to a minimum of 25ms\n        if (stepInterval > 25) stepInterval = Math.max(25, stepInterval - 0.5);\n        placeApple();\n      } else {\n        snake.pop();\n      }\n\n      lastDir = dir;\n    };\n\n    // input handling\n    const keyHandler = (e) => {\n      const k = e.key.toLowerCase();\n      let next = null;\n      if (k === \"arrowup\" || k === \"w\") next = { x: 0, y: -1 };\n      if (k === \"arrowdown\" || k === \"s\") next = { x: 0, y: 1 };\n      if (k === \"arrowleft\" || k === \"a\") next = { x: -1, y: 0 };\n      if (k === \"arrowright\" || k === \"d\") next = { x: 1, y: 0 };\n      if (k === \" \") {\n        // space toggles pause only when game is not over; if game is over do nothing\n        if (!gameOverRef.current) {\n          runningRef.current = !runningRef.current;\n          setRunning(runningRef.current);\n        }\n      }\n      if (next) {\n        // prevent reversing directly\n        if (next.x === -lastDir.x && next.y === -lastDir.y) return;\n        dir = next;\n      }\n    };\n\n    // touch / swipe controls\n    let touchStart = null;\n    const touchStartHandler = (e) => {\n      const t = e.touches[0];\n      touchStart = { x: t.clientX, y: t.clientY };\n    };\n    const touchEndHandler = (e) => {\n      if (!touchStart) return;\n      const t = e.changedTouches[0];\n      const dx = t.clientX - touchStart.x;\n      const dy = t.clientY - touchStart.y;\n      if (Math.abs(dx) > Math.abs(dy)) {\n        if (dx > 20) {\n          // right\n          if (!(lastDir.x === 1 && lastDir.y === 0)) dir = { x: 1, y: 0 };\n        } else if (dx < -20) {\n          if (!(lastDir.x === -1 && lastDir.y === 0)) dir = { x: -1, y: 0 };\n        }\n      } else {\n        if (dy > 20) {\n          if (!(lastDir.x === 0 && lastDir.y === 1)) dir = { x: 0, y: 1 };\n        } else if (dy < -20) {\n          if (!(lastDir.x === 0 && lastDir.y === -1)) dir = { x: 0, y: -1 };\n        }\n      }\n      touchStart = null;\n    };\n\n  // initialize\n  resetState();\n    draw();\n\n    window.addEventListener(\"keydown\", keyHandler);\n    canvas.addEventListener(\"touchstart\", touchStartHandler, { passive: true });\n    canvas.addEventListener(\"touchend\", touchEndHandler, { passive: true });\n\n    // Use requestAnimationFrame with a fixed-step accumulator for smooth rendering\n    let rafId = null;\n    let lastTime = 0;\n    let acc = 0;\n\n    const loop = (time) => {\n      if (!lastTime) lastTime = time;\n      const delta = time - lastTime;\n      lastTime = time;\n      acc += delta;\n\n      // perform steps at the configured speed (ms per step)\n      // use the mutable stepInterval so eating apples speeds the loop\n      const effectiveInterval = Math.max(25, stepInterval);\n      while (acc >= effectiveInterval) {\n        if (runningRef.current) step();\n        acc -= effectiveInterval;\n      }\n\n      // draw every frame to keep visuals responsive\n      draw();\n      rafId = requestAnimationFrame(loop);\n    };\n\n    rafId = requestAnimationFrame(loop);\n\n    // handle resize\n    const ro = new ResizeObserver(() => {\n      const c = computeSize();\n      scale = c.scale;\n      draw();\n    });\n    const observedNode = containerRef.current;\n    if (observedNode) ro.observe(observedNode);\n\n    // restart on tick change\n    // tick is a state value we can bump to force a restart\n    // we capture it through closure by returning a cleanup that doesn't depend on it; to respond to tick changes we re-run effect\n\n    return () => {\n  if (rafId) cancelAnimationFrame(rafId);\n  window.removeEventListener(\"keydown\", keyHandler);\n  canvas.removeEventListener(\"touchstart\", touchStartHandler);\n  canvas.removeEventListener(\"touchend\", touchEndHandler);\n  if (observedNode) ro.disconnect();\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [tick, percentageWidth, startSnakeSize, appleColor, snakeColor, gridSize, speed]);\n\n  // controls handlers\n  const toggleRunning = () => {\n    if (gameOver) {\n      // restart\n      runningRef.current = true;\n      setRunning(true);\n      setGameOver(false);\n      gameOverRef.current = false;\n      setScore(0);\n      setNewHighScore(false);\n      setTick((t) => t + 1);\n    } else {\n      runningRef.current = !runningRef.current;\n      setRunning(runningRef.current);\n    }\n  };\n\n  const restart = () => {\n    // bump tick to recreate internal game state\n    runningRef.current = true;\n    setRunning(true);\n    setGameOver(false);\n    gameOverRef.current = false;\n    setScore(0);\n    setTick((t) => t + 1);\n  };\n\n  return (\n    <section id=\"snake\" ref={containerRef}>\n      <div className=\"overflow-hidden text-center h-full h-screen\">\n        <h2 className=\"text-white text-3xl mb-1 font-medium pt-10 mt-12\">Use arrows or W/A/S/D keys to play:</h2>\n\n        <div className=\"flex justify-center pt-5\">\n          <div style={{ width: `${percentageWidth}%` }} className=\"relative max-w-[640px] pb-16 mx-auto\">\n            <div className=\"flex justify-between items-center mb-2\">\n              <div className=\"text-white\">Score: {score}</div>\n              <div className=\"text-white\">High: {highScore}</div>\n            </div>\n            <canvas ref={canvasRef} className=\"block w-full h-auto border-4 border-white rounded-md shadow-lg bg-[#0f172a]\" />\n            <div className=\"absolute left-1/2 -translate-x-1/2 bottom-3 flex gap-2\">\n              <button onClick={toggleRunning} className=\"px-3 py-1 rounded bg-slate-700 text-white\">\n                {running ? \"Pause\" : gameOver ? \"Start\" : \"Resume\"}\n              </button>\n              <button onClick={restart} className=\"px-3 py-1 rounded bg-slate-700 text-white\">Restart</button>\n            </div>\n            {gameOver && (\n              <div style={{ color: \"#f87171\", marginTop: 8 }}>\n                Game Over — final score: {score}\n                <div>{newHighScore ? \"New local high score!\" : \"\"}</div>\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </section>\n  );\n};\n\nexport default PlaySnake;"],"names":["_ref","percentageWidth","startSnakeSize","appleColor","snakeColor","gridSize","speed","canvasRef","useRef","containerRef","runningRef","gameOverRef","running","setRunning","useState","score","setScore","highScore","setHighScore","parseInt","localStorage","getItem","newHighScore","setNewHighScore","gameOver","setGameOver","tick","setTick","useEffect","setItem","String","canvas","current","ctx","getContext","size","computeSize","containerWidth","clientWidth","pct","parseFloat","canvasPx","Math","max","floor","scale","width","height","undefined","imageSmoothingEnabled","snake","dir","x","y","lastDir","apple","currentScore","stepInterval","placeApple","spot","random","collision","i","length","draw","fillStyle","fillRect","forEach","s","step","head","some","h","unshift","pop","keyHandler","e","k","key","toLowerCase","next","touchStart","touchStartHandler","t","touches","clientX","clientY","touchEndHandler","changedTouches","dx","dy","abs","resetState","startX","startY","push","window","addEventListener","passive","rafId","lastTime","acc","loop","time","delta","effectiveInterval","requestAnimationFrame","ro","ResizeObserver","c","observedNode","observe","cancelAnimationFrame","removeEventListener","disconnect","_jsx","id","ref","children","_jsxs","className","style","concat","onClick","toggleRunning","restart","color","marginTop"],"sourceRoot":""}